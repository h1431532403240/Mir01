# 庫存管理系統技術架構文檔

## �� 最新更新

### 2025-01-25 分類管理拖曳排序功能
- **問題**：分類管理頁面無法調整分類的顯示順序，需要拖曳排序功能
- **解決方案**：
  1. **後端實現**：
     - 新增 `sort_order` 欄位到 categories 表
     - 建立 `POST /api/categories/batch-reorder` API 端點
     - 使用事務處理確保排序更新的原子性
     - 新增 `CategoryService` 處理複雜的排序邏輯
  2. **前端實現**：
     - 建立 `DraggableCategoriesTable` 組件支援拖曳功能
     - 使用 `@dnd-kit` 套件實現流暢的拖曳體驗
     - 實現樂觀更新（Optimistic Update）提升使用者體驗
     - 新增 `useReorderCategories` Hook 處理 API 通訊
  3. **功能特點**：
     - 只支援頂層分類拖曳，子分類維持原有順序
     - 拖曳時有視覺反饋（半透明效果）
     - 失敗時自動回滾到原始順序
     - 成功後顯示 Toast 通知
- **技術細節**：
  - 使用 `arrayMove` 實現陣列元素重新排序
  - 透過 `hasReordered` 標記避免外部資料更新覆蓋本地狀態
  - 使用 `useEffect` 監聽狀態變化並自動同步到後端
- **影響範圍**：
  - `inventory-api/app/Http/Controllers/Api/CategoryController.php` - 新增 reorder 方法
  - `inventory-api/app/Services/CategoryService.php` - 新增服務類
  - `inventory-api/database/migrations/` - 新增 sort_order 欄位遷移
  - `inventory-client/src/components/categories/DraggableCategoriesTable.tsx` - 新增拖曳表格組件
  - `inventory-client/src/hooks/queries/useEntityQueries.ts` - 新增 useReorderCategories Hook
  - `inventory-client/src/components/categories/CategoriesClientPage.tsx` - 整合拖曳功能

### 2025-01-25 拖曳排序功能優化 - 「瞬時響應」作戰
- **問題**：原實現使用本地狀態管理，存在狀態同步複雜性和潛在的無限循環問題
- **優化方案**：
  1. **Hook 層級優化**：
     - 升級 `useReorderCategories` Hook，加入 `onMutate`、`onError` 和 `onSettled` 回調
     - 在 `onMutate` 中實現樂觀更新，直接修改 React Query 快取
     - 在 `onError` 中實現錯誤回滾，使用快照恢復原始狀態
     - 在 `onSettled` 中確保最終一致性，背景同步伺服器數據
  2. **組件層級簡化**：
     - 移除 `DraggableCategoriesTable` 中的本地狀態管理
     - 移除 `localCategories` 和 `hasReordered` 狀態
     - 直接使用從 `useCategories` 獲取的數據
     - 簡化 `handleDragEnd`，只負責計算新順序並觸發 mutation
  3. **技術優勢**：
     - **真正零延遲**：在 API 請求前就更新 UI，完全消除等待感
     - **優雅回滾**：失敗時使用保存的快照完美恢復
     - **程式碼簡潔**：移除複雜的狀態同步邏輯
     - **無感同步**：背景同步伺服器數據，對用戶透明
- **關鍵實現**：
  - 使用 `queryClient.setQueryData` 直接操作快取
  - 使用 `queryClient.cancelQueries` 防止覆蓋樂觀更新
  - 使用 context 物件在回調間傳遞快照數據
- **影響範圍**：
  - `inventory-client/src/hooks/queries/useEntityQueries.ts` - 升級 useReorderCategories Hook
  - `inventory-client/src/components/categories/DraggableCategoriesTable.tsx` - 簡化組件邏輯

### 2025-01-12 新增商品詳情頁
- **問題**：商品列表點擊商品名稱跳轉到 404 錯誤頁，因為缺少商品詳情頁
- **解決方案**：
  1. 創建 `/products/[productId]/page.tsx` 商品詳情頁面
  2. 展示商品完整資訊：
     - 商品圖片、名稱、描述、分類
     - 價格範圍和總庫存統計卡片
     - 規格變體列表（SKU、規格、價格、庫存）
     - 各門市庫存分布統計
  3. 新增 `formatPrice` 工具函數統一價格格式化
  4. 提供返回列表和編輯商品的便捷操作按鈕
  5. 統一採用儀表板的 Card 樣式風格：
     - 漸變背景 `bg-gradient-to-t from-primary/5 to-card`
     - 陰影效果 `shadow-xs`
     - 卡片標題區加入圖標增強視覺層次
     - 響應式字體大小和容器查詢
     - 統計數據使用大號字體突出重點
- **影響範圍**：
  - `inventory-client/src/app/(app)/products/[productId]/page.tsx` - 新增詳情頁
  - `inventory-client/src/lib/utils.ts` - 新增 formatPrice 函數

### 2025-01-12 商品庫存狀態分類功能
- **問題**：商品清單的庫存狀態只簡單顯示「有庫存」或「無庫存」，無法反映部分變體有庫存的情況
- **解決方案**：
  1. 實現3種庫存狀態分類：
     - **有庫存**：所有變體都有庫存（包括單一規格商品）
     - **部分庫存**：部分變體有庫存
     - **無庫存**：所有變體都沒有庫存
  2. 使用不同的 Badge 顏色和圖標來區分狀態：
     - 有庫存：綠色 secondary Badge + CheckCircle 圖標
     - 部分庫存：灰色 outline Badge + Package 圖標
     - 無庫存：紅色 destructive Badge + Box 圖標
  3. 精確計算每個變體的庫存總量，提供更準確的庫存狀態判斷
- **影響範圍**：
  - `inventory-client/src/components/products/columns.tsx` - 狀態欄位邏輯重構

### 2025-01-12 訂單付款功能增強
- **問題**：部分付款功能太邊緣化，只能通過 Modal 記錄但看不到歷史
- **解決方案**：
  1. 在訂單詳情頁新增付款進度卡片，顯示已付/未付金額和視覺化進度條
  2. 新增付款歷史卡片，展示所有付款記錄（金額、方式、日期、操作人員）
  3. 擴展 ProcessedOrder 類型定義以支援 payment_records
  4. 增強快取同步機制，確保付款後無需手動刷新頁面
- **影響範圍**：
  - `OrderDetailComponent.tsx` - UI 改進
  - `api-helpers.ts` - 類型定義擴展
  - `useEntityQueries.ts` - 快取同步優化

### 2025-01-26 分類拖曳排序快取鍵修復
- **問題**：拖曳排序功能實現後，發現拖曳操作不會即時更新畫面，需要手動刷新頁面才能看到新的排序
- **根本原因**：React Query 快取鍵不匹配
  - `useCategories` Hook 使用的快取鍵：`[...QUERY_KEYS.CATEGORIES, filters]`（實際為 `['categories', {}]`）
  - `useReorderCategories` 樂觀更新使用的快取鍵：`QUERY_KEYS.CATEGORIES`（即 `['categories']`）
  - 快取鍵不匹配導致樂觀更新無法正確工作
- **解決方案**：
  1. **修正快取鍵**：
     ```typescript
     // 修正前：使用錯誤的快取鍵
     const previousCategories = queryClient.getQueryData<CategoryNode[]>(QUERY_KEYS.CATEGORIES);
     
     // 修正後：使用正確的快取鍵，匹配 useCategories 的實際快取鍵
     const queryKey = [...QUERY_KEYS.CATEGORIES, {}];
     const previousCategories = queryClient.getQueryData<CategoryNode[]>(queryKey);
     ```
  2. **增強錯誤處理**：在 context 中保存 `queryKey`，確保錯誤回滾時使用正確的快取鍵
  3. **核心要點**：React Query 的樂觀更新必須確保更新的快取鍵與查詢時使用的快取鍵完全一致
- **影響範圍**：
  - `inventory-client/src/hooks/queries/useEntityQueries.ts` - 修復 useReorderCategories Hook 的快取鍵問題

---

## 📋 專案概述

本專案是一個現代化的庫存管理系統，採用前後端分離的架構設計，專為中小企業庫存管理需求而開發。系統包含商品管理、進貨管理、庫存追蹤等核心功能。

## 🏗️ 系統架構

### 整體架構圖

```
┌─────────────────┐    HTTP/REST API    ┌─────────────────┐
│                 │ ◄─────────────────► │                 │
│  前端應用程式    │                     │  後端API服務     │
│  (Next.js 15)   │                     │  (Laravel 12)   │
│                 │                     │                 │
└─────────────────┘                     └─────────────────┘
                                                 │
                                                 ▼
                                        ┌─────────────────┐
                                        │                 │
                                        │  資料庫層        │
                                        │  (MySQL/SQLite) │
                                        │                 │
                                        └─────────────────┘
```

### 技術架構層次

- **展示層 (Presentation Layer)**: Next.js 15 + React 19
- **API層 (API Layer)**: Laravel 12 RESTful API
- **業務邏輯層 (Business Logic Layer)**: Laravel Services + Domain Models
- **資料存取層 (Data Access Layer)**: Eloquent ORM
- **資料庫層 (Database Layer)**: MySQL/SQLite

## 🚀 技術棧詳細資訊

### 前端技術棧 (inventory-client)

#### 核心框架與函式庫
- **Next.js 15.3.3**: React 全端框架，支援 SSR/SSG
- **React 19.0.0**: 使用者介面函式庫
- **TypeScript 5**: 類型安全的 JavaScript 超集

#### UI與樣式
- **Tailwind CSS 4**: 實用優先的 CSS 框架
- **shadcn/ui**: 高品質的 React 元件庫
- **Radix UI**: 無障礙的底層 UI 基礎元件
- **Lucide React**: 現代化圖示庫
- **Tabler Icons**: 補充圖示庫
- **Noto Sans TC**: 思源黑體，支援繁體中文

#### 狀態管理與資料獲取
- **TanStack Query v5**: 伺服器狀態管理與快取
- **openapi-fetch**: 類型安全的 API 客戶端
- **Zod**: 執行時類型驗證

#### 進階功能
- **@dnd-kit**: 拖放功能實作
- **TanStack Table v8**: 高效能資料表格
- **Recharts**: 資料視覺化圖表
- **next-themes**: 深色/淺色主題切換

#### 開發工具
- **ESLint 9**: 程式碼品質檢查
- **OpenAPI TypeScript**: 自動生成 API 類型定義

### 後端技術棧 (inventory-api)

#### 核心框架
- **Laravel 12.0**: PHP 全端框架
- **PHP 8.2**: 現代 PHP 版本

#### 資料處理與 API
- **Eloquent ORM**: Laravel 的活躍記錄實作
- **Laravel Sanctum 4.0**: API 認證
- **Spatie Laravel Data 4.15**: 資料傳輸物件 (DTO)
- **Spatie Query Builder 6.3**: 動態查詢建構器

#### 文檔與測試
- **Scribe 5.2**: 自動生成 API 文檔
- **PHPUnit 11.5**: 單元測試框架

#### 擴充功能套件
- **Spatie Laravel Permission 6.19**: 角色權限管理
- **Spatie Laravel ActivityLog 4.10**: 活動日誌追蹤
- **Spatie Laravel MediaLibrary 11.13**: 媒體檔案管理

#### 開發工具
- **Laravel Pint**: 程式碼格式化
- **Laravel Sail**: Docker 開發環境

## 🎯 軟體設計原則

### 1. 單一職責原則 (Single Responsibility Principle)

**後端實作範例**:
```php
/**
 * 進貨管理服務類別
 * 專門處理進貨相關的業務邏輯
 */
class PurchaseService
{
    /**
     * 建立新的進貨單
     * 單一職責：僅負責進貨單的建立邏輯
     */
    public function createPurchase(PurchaseData $purchaseData)
    {
        // 業務邏輯實作...
    }
}
```

**前端實作範例**:
```typescript
/**
 * 專門負責產品資料管理的自定義 Hook
 * 單一職責：僅處理產品相關的 API 操作
 */
export function useProducts() {
    return useQuery({
        queryKey: QUERY_KEYS.PRODUCTS,
        queryFn: async () => {
            // API 調用邏輯...
        },
    });
}
```

### 2. 開放封閉原則 (Open-Closed Principle)

- **API 版本控制**: 使用 `/api/` 命名空間，便於擴充新版本
- **元件可擴充性**: 使用 Radix UI 作為基礎，可輕鬆自定義樣式和行為

### 3. 介面隔離原則 (Interface Segregation Principle)

**前端介面分離**:
```typescript
// 專門的查詢鍵定義
export const QUERY_KEYS = {
    PRODUCTS: ['products'] as const,
    PRODUCT: (id: number) => ['products', id] as const,
} as const;
```

### 4. 依賴反轉原則 (Dependency Inversion Principle)

- **後端**: 透過 Laravel 的服務容器進行依賴注入
- **前端**: 使用 React Context 和 Provider 模式管理依賴

## 🏛️ 設計模式實作

### 1. Repository Pattern (儲存庫模式)

**Laravel Eloquent 實作**:
```php
class ProductController extends Controller
{
    /**
     * 使用 Eloquent 作為資料存取層
     * 抽象化資料庫操作邏輯
     */
    public function index()
    {
        return QueryBuilder::for(Product::class)
            ->allowedFilters(['name', 'sku'])
            ->allowedSorts(['name', 'selling_price', 'created_at'])
            ->paginate(15);
    }
}
```

### 2. Data Transfer Object Pattern (資料傳輸物件模式)

**使用 Spatie Laravel Data**:
```php
/**
 * 產品資料傳輸物件
 * 確保資料結構的一致性和類型安全
 */
class ProductData extends Data
{
    public function __construct(
        public int $id,
        public string $name,
        public string $sku,
        public ?string $description,
        public float $selling_price,
        public float $cost_price,
    ) {}
}
```

### 3. Service Layer Pattern (服務層模式)

**業務邏輯封裝**:
```php
/**
 * 進貨服務層
 * 封裝複雜的業務邏輯，確保資料一致性
 */
class PurchaseService
{
    public function createPurchase(PurchaseData $purchaseData)
    {
        return DB::transaction(function () use ($purchaseData) {
            // 複雜的業務邏輯處理
            // 1. 建立進貨單
            // 2. 建立進貨項目
            // 3. 更新庫存
        });
    }
}
```

### 4. Query Object Pattern (查詢物件模式)

**Spatie Query Builder 實作**:
```php
QueryBuilder::for(Product::class)
    ->allowedFilters(['name', 'sku'])
    ->allowedSorts(['name', 'selling_price', 'created_at'])
    ->paginate(15);
```

### 5. Hook Pattern (React Hooks 模式)

**自定義 Hook 封裝**:
```typescript
/**
 * 產品管理相關的 Hook
 * 封裝資料獲取、變更和快取邏輯
 */
export function useCreateProduct() {
    const queryClient = useQueryClient();
    
    return useMutation({
        mutationFn: async (productData) => {
            // API 調用邏輯
        },
        onSuccess: () => {
            // 快取更新邏輯
            queryClient.invalidateQueries({ queryKey: QUERY_KEYS.PRODUCTS });
        },
    });
}
```

### 6. Provider Pattern (提供者模式)

**React Context 實作**:
```typescript
/**
 * 全域狀態提供者
 * 管理主題、查詢客戶端等應用狀態
 */
export default function RootLayout({ children }) {
    return (
        <ThemeProvider>
            <QueryProvider>
                <SidebarProvider>
                    {children}
                </SidebarProvider>
            </QueryProvider>
        </ThemeProvider>
    );
}
```

## 📊 資料庫設計

### 核心資料表結構

```sql
-- 商品表
products
├── id (PK)
├── name
├── sku (唯一)
├── description
├── selling_price
├── cost_price
└── timestamps

-- 店鋪表
stores
├── id (PK)
├── name
├── address
└── timestamps

-- 庫存表
inventories
├── id (PK)
├── store_id (FK)
├── product_id (FK)
├── quantity
└── timestamps

-- 進貨單表
purchases
├── id (PK)
├── store_id (FK)
├── order_number
├── purchased_at
├── total_amount
└── timestamps

-- 進貨項目表
purchase_items
├── id (PK)
├── purchase_id (FK)
├── product_id (FK)
├── quantity
├── unit_price
└── timestamps
```

### 資料關聯設計

- **一對多關聯**: Store ↔ Inventory, Purchase ↔ PurchaseItem
- **多對多關聯**: Store ↔ Product (透過 Inventory)
- **外鍵約束**: 確保資料完整性

## 🔄 業務流程邏輯

### 1. 進貨流程

```mermaid
graph TD
    A[創建進貨單] --> B[驗證商品資訊]
    B --> C[計算總金額]
    C --> D[建立進貨記錄]
    D --> E[建立進貨項目]
    E --> F[更新庫存數量]
    F --> G[交易完成]
    
    B --> H[驗證失敗]
    H --> I[返回錯誤]
```

### 2. 庫存管理流程

```mermaid
graph TD
    A[查詢庫存] --> B[檢查商品存在]
    B --> C[計算可用數量]
    C --> D[顯示庫存資訊]
    
    E[進貨] --> F[增加庫存]
    G[銷售] --> H[減少庫存]
    
    F --> I[更新庫存記錄]
    H --> I
```

## 🔐 安全性設計

### API 安全
- **Laravel Sanctum**: API 權杖認證
- **CORS 設定**: 跨域請求控制
- **輸入驗證**: Request 類別驗證
- **SQL 注入防護**: Eloquent ORM 參數化查詢

### 前端安全
- **類型安全**: TypeScript 編譯時檢查
- **輸入驗證**: Zod 執行時驗證
- **XSS 防護**: React 自動跳脫
- **HTTPS**: 生產環境強制使用

## 📈 效能最佳化

### 後端效能
- **資料庫索引**: 主鍵、外鍵、查詢欄位
- **Eloquent 最佳化**: 使用 `select()` 限制欄位
- **查詢快取**: Laravel 查詢結果快取
- **分頁處理**: 避免大量資料載入

### 前端效能
- **React Query 快取**: 伺服器狀態智慧快取
- **懶加載**: 動態導入非關鍵元件
- **圖片最佳化**: Next.js Image 元件
- **程式碼分割**: 自動程式碼分割
- **Tree Shaking**: 移除未使用的程式碼

## 🧪 測試策略

### 後端測試
- **單元測試**: PHPUnit 測試個別方法
- **功能測試**: 測試 API 端點
- **整合測試**: 測試服務間互動

### 前端測試
- **元件測試**: 測試 React 元件行為
- **Hook 測試**: 測試自定義 Hook
- **E2E 測試**: 端到端使用者流程測試

## 📱 響應式設計

### 行動優先設計
- **Tailwind CSS**: 行動優先的斷點系統
- **useIsMobile Hook**: 裝置檢測
- **Drawer 元件**: 行動裝置適配的對話框
- **Touch 友善**: 觸控操作最佳化

### 跨瀏覽器支援
- **現代瀏覽器**: Chrome、Firefox、Safari、Edge
- **向後相容**: 透過 Babel 和 Polyfill
- **漸進式增強**: 基礎功能優先

## 🚀 部署與維運

### 開發環境
- **Next.js Dev Server**: 熱重載開發伺服器
- **API 文檔**: Scribe 自動生成文檔

### 生產環境建議
- **容器化部署**: Docker + Docker Compose
- **反向代理**: Nginx
- **資料庫**: MySQL 8.0+
- **檔案儲存**: S3 相容儲存
- **監控**: Laravel Telescope + APM 工具

## 📚 程式碼品質

### 程式碼規範
- **PHP**: PSR-12 編碼標準
- **JavaScript/TypeScript**: ESLint + Prettier
- **CSS**: Tailwind CSS 類別排序

### 文檔註解
- **PHP DocBlock**: 完整的方法和類別文檔
- **TypeScript JSDoc**: 函式和介面說明
- **README**: 專案設定和使用說明

### 版本控制
- **Git Flow**: 功能分支開發流程
- **語意化版本**: SemVer 版本標記
- **Conventional Commits**: 標準化提交訊息

## 🔮 未來擴充規劃

### 功能擴充
- **多語言支援**: i18n 國際化
- **即時通知**: WebSocket 推送
- **進階報表**: 更豐富的資料分析
- **行動應用**: React Native 跨平台應用

### 技術升級
- **微服務架構**: 服務拆分和獨立部署
- **GraphQL**: 更靈活的 API 查詢
- **Redis**: 高效能快取和會話儲存
- **Elasticsearch**: 全文搜尋功能

## 🔧 開發流程與工具

### API 文檔生成流程

為了確保前後端 API 契約的一致性，我們建立了標準化的文檔生成流程：

#### 自動化腳本（推薦）
```bash
# 執行一鍵生成腳本
cd inventory-api
./regenerate-api-docs.sh
```

#### 手動步驟
```bash
# 1. 生成 Scribe API 文檔
./vendor/bin/sail artisan scribe:generate

# 2. 複製到前端專案
cp storage/app/private/scribe/openapi.yaml ../inventory-client/openapi.yaml

# 3. 生成 TypeScript 類型定義
cd ../inventory-client && npm run api:types
```

### 開發注意事項

1. **契約優先開發**: 修改 API 時先更新 PHPDoc 註釋
2. **日期類型規範**: 
   - 根據 Scribe 官方文檔，`@bodyParam` 和 `@queryParam` 只支援 `string`、`integer`、`number`、`boolean`、`object` 和 `file` 類型
   - **建議統一使用 `string` 類型表示日期**，並在描述中說明格式
   - 日期格式：`string` 類型，說明 `格式：Y-m-d`
   - 日期時間格式：`string` 類型，說明 `格式：Y-m-d H:i:s`
3. **版本控制**: 生成的 `openapi.yaml` 和 `api.ts` 應該納入版本控制
4. **測試驗證**: 更新 API 後執行 `npm run build` 確認無類型錯誤

## API 契約同步

### 工作流程

1. **後端變更**
   - 修改 Controller 的 PHPDoc 註解
   - 更新對應的 Form Request 類別

2. **生成 API 文檔**
   ```bash
   cd inventory-api
   ./regenerate-api-docs.sh
   ```

3. **前端使用**
   - TypeScript 類型會自動更新到 `src/types/api.ts`
   - 使用 apiClient 進行類型安全的 API 調用

### 重要技術決策

#### 類型標準化 (2025-01-20)

經過技術評估，我們決定將所有日期相關的 API 參數標準化為 `string` 類型：

1. **背景**
   - 團隊早期使用了 Scribe 不支持的類型（`date`、`datetime`、`numeric`）
   - 這些非標準類型導致 openapi-typescript 生成錯誤的 TypeScript 類型

2. **技術分析**
   - Scribe 官方只支持：`string`、`integer`、`number`、`boolean`、`object`、`file`
   - 使用非標準類型不會報錯，但會直接傳遞到 OpenAPI 文檔中
   - openapi-typescript 無法識別這些類型，生成 `Record<string, never>`

3. **決策內容**
   - 所有日期類型統一使用 `string`，並在描述中註明格式
   - 例如：`@queryParam start_date string 起始日期 (格式: Y-m-d). Example: 2025-01-01`
   - `numeric` 類型改為標準的 `number`

4. **已完成的遷移**
   - CustomerController: `date` → `string`
   - ReportController: `date` → `string`  
   - InventoryTransferController: `date` → `string`
   - InventoryManagementController: `date` → `string`
   - OrderController: `date`/`datetime` → `string`, `numeric` → `number`
   - InstallationController: 已使用標準 `string` 類型

5. **遷移後的效果**
   - 所有 TypeScript 類型正確生成
   - 不再需要 fix-openapi-types.php 腳本（新代碼）
   - 前端編譯無錯誤